

TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

一个数据： 14字节Ethernet报头，20字节IP报头，20字节TCP报头，4字节FCS，剩下的都是数据

#### [TCP三次握手](https://wenku.baidu.com/view/786b56a4f524ccbff1218470.html)

<img src="https://img-blog.csdn.net/20180717201939345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 67%;" />

**序列号seq**：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；**序列号seq就是这个报文段中的第一个字节的数据编号**

**确认号ack**：占4个字节，**期待收到对方下一个报文段的第一个数据字节的序号**；

序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。

**确认ACK**：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效

**同步SYN**：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。

**终止FIN**：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接

<img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 67%;" />

**第一次握手：**
客服端发送SYN=1，ACK=0到服务端，并进入SYN_SENT状态，等待服务器确认（seq是随机值x）

**第二次握手：**

服务器收到数据，发送确认号ack=x+1，同时自己也发送一个序号包seq=y，SYN=1,ACK=1,此时服务器进入SYN_RECV状态

**第三次握手：**

客户端收到服务器数据，发送ACK=1,SYN=0以及序号seq=x+1,确认号ack=y+1

**第一次传输数据时：**

客户端发出的序号seq和第三次握手时一样是x+1，这是有数据报文了， 下一次的序号seq会在此基础上加上数据长度



**为什么不是两次：**

A发送的一个连接请求在网络结点的时间滞留，以至于延误到连接释放的某个 时间才到达B，B收到这个请求的报文段后，误以为A又发出了一次新的请求连接， 于是向A发送确认报文段，同意建立连接。但是由于A并没有发出新的请求连接， 所以A不会理睬B的确认也不会向B发送数据。但B却认为连接已经建立，一直 等待A发来数据。B的资源就白白浪费了。



**为什么呢不是4次：**

服务器回复 ACK和ack=x+1   和   SYN=1和seq=y 两步可以合并，所以只需3次，可以提高连接的速度与效率。

三次是保证双方互相明确对方能收能发的最低值。

<img src="https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:67%;" />

**第一次挥手：**

客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号



**第二次挥手：**

服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，**客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了**，但是服务器若发送数据，客户端依然要接受。**这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间**

客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）

**第三次挥手：**

服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

**第四次挥手：**

客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

**服务器只要收到了客户端发出的确认，立即进入CLOSED状态。**同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些



##### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文

在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间(一来一回)。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。

##### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。**服务器每收到一次客户端的请求后都会重新复位这个计时器**，**时间通常是设置为2小时**，若两小时还没有收到客户端的任何数据，服务器就会**发送一个探测报文段，以后每隔75秒钟发送一次**。若**一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接**。



##### 服务端崩溃：

**客户端会持续重传未收到确认的数据分节（TCP软件负责），持续一段时间后仍未收到确认则放弃（通常是9分钟）**。如果是服务器崩溃则本机TCP软件会向用户进程显示套接字错误并置错误码，**如果是中间路由器判定服务器主机不可达则会返回一个ICMP消息**，那么TCP软件收到该ICMP消息会向用户进程显示套接子错误并置错误码。我们可以通过错误码来判断到底是哪种错误。

ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息,是属于网络层协议。

##### 如何保证可靠传输

https://www.bilibili.com/read/cv6625076

●应用数据被分割成TCP认为最适合发送的数据包，**TCP给发送的每一个包进行编号**， 接收方对数据包进行排序，把有序数据传送给应用层。
●**超时重传**:当TCP发出一个段后，它启动一个定时器，等待目标端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

​	停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组(认为刚才发送过的分组丢失了)。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返
时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃
该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

●**且TCP的接收端会丢弃重复的数据**.
●**校验和**: TCP将保持它首部和数据的检验和。这是一 个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP接收端将丢弃这个报文段和不确认收到此报文段。
●**流量控制**: TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送
接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送
的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。(TCP利用滑动窗口实现流量控制)
●拥塞控制:当网络拥塞时，减少数据的发送。
●停止等待ARQ协议(stop and wait) 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

​	停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到	确认后再发下一个分组。为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传	输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。

##### 拥塞控制算法

慢开始：发送窗口由1开始经过一次传播就加倍

拥塞避免：经过一个往返时间RTT，窗口+1

快重传、快回复（FRR）：连续收到3个相同的确认包x，立即重传x+1，单个包丢失可以有效工作，多个不行

#### Http和Https

http超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据

HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，**加密数据包**。HTTPS使用的主要目的是提供对网站服务器的**身份认证，同时保护交换数据的隐私与完整性**。

<img src="https://img-blog.csdn.net/20180719103559793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="内容加密和数据完整性保护" style="zoom:50%;" />



#### TCP和UDP

TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，**而且在数据传递时，有确认、窗口、重传、拥塞控制机制**，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

UDP的优点： **快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制**，**UDP是一个无状态的传输协议**，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ………… 什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP ……

有些应用场景对可靠性要求不高会用到UPD，比如长视频，要求速率

#### TCP和Http

TCP是底层通讯协议，定义的是数据传输和连接方式的规范
HTTP是应用层协议，定义的是传输数据的内容的规范
HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP   HTTP支持的是www服务 而TCP/IP是协议 

一个TCP连接是可以响应多个HTTP请求



两个http请求的生命周期不能重叠，任意两个HTTP请求从开始到结束的时间在同一个TCP连接里不能重
叠。但是http pipeline可以支持同时发送，服务器根据先后顺序返回响应，但是浏览器没法判断返回的响应对应哪一个请求，默认关闭。http2使用multiplexing支持多路传输



##### http1.1如何提高页面加载效率：

复用tcp,处理多个http请求

建立多个tcp连接，chrome最多允许6个



#### POST和GET

https://blog.csdn.net/qq_41175951/article/details/90441792

#### 请求头

https://www.cnblogs.com/wanghuaqiang/p/12093563.html

##### Transfer-Encoding: chunked

采用Content-Length表明长度需要大的buffer缓存内容；用此编码方式分块传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF（\r\n），也不包括分块数据结尾的 CRLF。最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束

```js
sock.write('HTTP/1.1 200 OK\r\n');
        sock.write('Transfer-Encoding: chunked\r\n');
        sock.write('\r\n');

        sock.write('b\r\n');
        sock.write('01234567890\r\n');

        sock.write('5\r\n');
        sock.write('12345\r\n');

        sock.write('0\r\n');
        sock.write('\r\n');
```

#### 转发和重定向

请求转发是服务器内部跳转，只有一次请求，地址栏不变

request.getRequestDispatcher().forward()

<img src="/Users/kangkang/Library/Application Support/typora-user-images/image-20200811002026408.png" alt="image-20200811002026408" style="zoom:30%;" />

重定向是浏览器跳转，两次请求，无法共享数据，地址栏是第二次请求的url

response.sendRedirect()

<img src="/Users/kangkang/Library/Application Support/typora-user-images/image-20200811001848644.png" alt="image-20200811001848644" style="zoom:30%;" />

#### Session

#### JSP内置对象

<img src="/Users/kangkang/Library/Application Support/typora-user-images/image-20200811002914571.png" alt="image-20200811002914571" style="zoom:50%;" />

#### 黏包和拆包

[TCP粘包拆包的产生原因分析及解决思路](https://blog.csdn.net/fgx_123456/article/details/80031821)

各两种基础原因

办法：封装为固定长度；包首表明每个包长度；
